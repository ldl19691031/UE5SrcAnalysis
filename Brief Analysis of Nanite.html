<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Brief Analysis of Nanite</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="94be60f2-9243-4ba3-ae62-fa4bcf7d9379" class="page sans"><header><h1 class="page-title">Brief Analysis of Nanite</h1></header><div class="page-body"><p id="4551fdeb-5f2c-4d54-a50c-6695acc2056d" class="">For the global pipeline of Unreal Engine 5, please check this: <a href="https://www.notion.so/Brief-Analysis-of-UE5-Rendering-Pipeline-feedcb9174aa4af2af936fbb02a9e390">https://www.notion.so/Brief-Analysis-of-UE5-Rendering-Pipeline-feedcb9174aa4af2af936fbb02a9e390</a></p><p id="dc531001-a188-4b03-972b-9ffa1b8d11ce" class="">In this article, I will write my own analysis of Nanite&#x27;s source code. I only want to touch on the basic progress but not try to analyze the ideas behind the Nanite. This much beyond my skill. For the ideas behind Nanite, I recommend waiting for the official SIGGRAPH presentation.</p><p id="b4db2d88-897e-4196-96c3-fe53b1a1e743" class="">This is the offical page of Nanite : <a href="https://docs.unrealengine.com/5.0/en-US/RenderingFeatures/Nanite/">https://docs.unrealengine.com/5.0/en-US/RenderingFeatures/Nanite/</a></p><p id="f4b177e9-637b-43fa-aef6-a6f204ea0e28" class="">Also, this is also anther good analysis of Nanite: <a href="http://www.elopezr.com/a-macro-view-of-nanite/">http://www.elopezr.com/a-macro-view-of-nanite/</a></p><p id="2222a5f5-ca80-415d-905d-68ffcc5fe995" class="">And the official Inside Unreal talk: <a href="https://www.youtube.com/watch?v=TMorJX3Nj6U">https://www.youtube.com/watch?v=TMorJX3Nj6U</a></p><p id="22c27cbd-0beb-4222-b98b-a85b2d4a2501" class=""><strong>WARNING</strong>: I&#x27;m not a developer of Epic, and this article may contains mistakes and mislead you. This article focus on the details of Nanite&#x27;s source so I recommend you to at least watch the videos of Inside Unreal&#x27;s Nanite talk.</p><h1 id="a6a3e577-dd9b-4315-b144-08f0deefff91" class="">Basic concepts</h1><p id="51b8fbd0-a7e7-4c67-877b-77760087191b" class="">Nanite contains two parts: a pre-calculation system for preprocessing the meshes, generate mesh clusters and LODs; and a runtime system for loading and rendering.</p><figure id="748b85e3-917d-4107-ac04-786c435684dd" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled.png"><img style="width:403px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled.png"/></a></figure><p id="f696ac15-03df-49d6-bce3-1bbf174fc6b6" class="">So, the clusters will be the basic elements of a Nanite mesh. During the rendering, Nanite needs to:</p><ul id="17fc5753-ba83-44e9-9549-fbf916dbf421" class="bulleted-list"><li>Culling: both instance culling and primitive culling</li></ul><ul id="8915d4bd-8876-4330-b6ce-7168d5e57214" class="bulleted-list"><li>Change the LOD: Nanite changes LOD level <strong>cluster-wise</strong>, which is different from many instance-wise LOD approaches. 
You can see only some of the clusters have changed:<figure id="9163abab-90f5-4f97-97ac-51b7b97b0d4c" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Nanite1.gif"><img style="width:634px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Nanite1.gif"/></a></figure></li></ul><ul id="79ca23ca-48a1-4722-8736-b4e9bb38be95" class="bulleted-list"><li>Rendering: By hardware and software rasterizer ( I discussed a little in the rendering pipeline analysis)</li></ul><p id="0b09b31f-ff6b-44c6-a589-006735b0bd5a" class="">In order to explain the mini-map of Nanite, I created this image:</p><figure id="95b6b90d-7dc8-4b8e-ae3e-9a78c35d7c09" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%201.png"><img style="width:1368px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%201.png"/></a></figure><p id="753120c6-988f-48d1-a908-4b8f17bb90bf" class="">First, Nanite generates a set of clusters based on the triangles, whichi becomes the leaf clusters.</p><p id="65d03595-9253-4e83-a82d-7f2ab7d7a50e" class="">Then, it will select a set of clusters as a new cluster group, and merge this group into a large cluster.(2 and 3)</p><p id="a934f13c-ceaa-4cc8-8885-3b78af7edf63" class="">Then, simplify this cluster, reduce the polygons but keep the boundary.(4)</p><p id="2a169151-a735-49ba-9ebf-bfb7a81f8d38" class="">Then, do a graph partition to split this large cluster into small parts. The parts are larger than the original clusters in (2)</p><p id="0d2b4082-fb58-40d7-af5a-1110337e3f39" class="">You can see cluster set B has the same boundary as a cluster set A. This means we can switch from A to B to reduce polygon without creating any seam on the boundary.</p><p id="5636cdf8-8f3d-4404-a697-f02dedd4bac3" class="">So, when can we apply this switch safely? Nanite creates a depenency graph (DAG) to repesent (6)</p><p id="8547e69d-e512-4aea-9b98-3e047a1bf6cb" class="">Finally, we break cluster set B and got a set of clusters again. Repeat these steps until the total cluster number less than a given threshold.</p><p id="893397e5-e61b-4994-a445-5627991d9378" class="">
</p><p id="068dbc23-d61c-4c29-9581-886bf4227968" class="">So, in theory, switching LODs will never cause some empty space in the mesh&#x27;s surface, because every switch will be boundary safe. </p><p id="7066cbcb-e544-45e5-9964-3c689db22733" class="">
</p><h1 id="253f637a-2f40-43c3-b799-f1925b35fa54" class="">Pre-processing</h1><p id="47f3ac98-61a7-4706-b014-70060b2dc82b" class="">The pre-processing happens in ue&#x27;s editor. When you enable Nanite for a static mesh, Nanite will build cluster data for this mesh and encode them, write to disk.</p><p id="89394e63-d7d6-43d6-aaed-8dce33a1eb66" class="">This processing happens in BuildNaniteData function in NaniteBuilder.cpp.</p><p id="81ba4697-ace4-48bf-b872-ab30ed0953b1" class="">The pre-processing outputs are an array of clusters and an array of goups.</p><h2 id="8f547226-afca-4e62-a81b-2580e9a3a234" class="">Cluster Data Structure</h2><p id="67e20244-6486-4b0b-8ffe-de40aafa019d" class="">So, let&#x27;s first look at the data that each cluster holds:</p><pre id="8a20f64f-5b26-43e4-b3cd-17d668ff1650" class="code"><code>	
TArray&lt; float &gt;		Verts;
	TArray&lt; uint32 &gt;	Indexes;

	FBounds		Bounds;
	FSphere		SphereBounds;
	FSphere		LODBounds;

	uint32		GroupIndex			= MAX_uint32;
	uint32		GroupPartIndex		= MAX_uint32;
	uint32		GeneratingGroupIndex= MAX_uint32;</code></pre><p id="9f2460c9-82c2-45f3-9fcd-0de6725af19a" class="">As a real example, this is a cluster data:</p><figure id="737f052e-7b99-437e-8bac-7dd10866e9c2" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%202.png"><img style="width:712px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%202.png"/></a></figure><p id="c89ad85a-527d-4a76-be45-04f7150757dd" class="">You can see, each cluster contains its own triangles and bounds. Also, it contains its boundary edges and external edges.</p><p id="6bbd691a-d44d-48b2-af15-6ce6debb1e91" class="">Beyond this, we have cluster groups, which contains a set of cluster groups:</p><pre id="e59efdf1-ddf1-485f-8113-a4d2953ba53f" class="code"><code>FSphere				Bounds;
	FSphere				LODBounds;
	float				MinLODError;
	float				MaxParentLODError;
	int32				MipLevel;
	uint32				MeshIndex;
	TArray&lt; uint32 &gt;	Children;</code></pre><h3 id="3efaba15-4009-419f-9b85-f0dbcb119bd3" class="">Dependency</h3><p id="12a75aa0-c504-43b3-9ce5-6b0e59e0247e" class="">So, with a cluster group as middle data, two levels of clusters&#x27; reference is like this:</p><p id="03c9305d-f6b7-43b4-bcb6-ba1a6243cd57" class=""> </p><figure id="4374e6e5-5c0e-4b0c-8691-dc6cd9cb88af" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%203.png"><img style="width:555px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%203.png"/></a></figure><p id="f5f2ccb1-7a5f-4cd7-8a79-341fd57d8e47" class="">Be careful, I didn&#x27;t say Cluster Group B will have a direct link to Cluster Group A. Actually, the generating group index is used as a data dependency. They are not organized as a tree by this info, it is much more complex than this. DO NOT mislead by this picture!</p><h3 id="413252f7-fcb5-4a88-b7ae-2b0bd710732a" class="">LOD Error</h3><p id="4c7eda2f-8207-4c04-809d-4a304acbde25" class="">In each group, it will calculate the LOD error. This part is really important and will answer the question that why we do not need a direct reference between Cluster Group A and B.</p><pre id="0ec4ed28-ff81-45b8-8851-bcdd01b556bd" class="code"><code>// Cluster
float		LODError = 0.0f;
// Cluster Group
	float				MinLODError;
	float				MaxParentLODError;</code></pre><p id="973462be-892e-4fb2-9673-6c7da2bdfb32" class="">For a cluster, the LOD error is just a number, but for a cluster group, the LOD error is a range [MinLODError, MaxParentLODError]. </p><p id="524f1844-9474-4f60-887a-f16912c731cc" class="">For the LOD error calculation:</p><figure id="45f0ec2b-b50a-4839-bde1-2aeca572b55c" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%204.png"><img style="width:566px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%204.png"/></a></figure><p id="49b71b1e-9f7e-4b9f-97b8-95f7e6f4d55e" class="">As we explained before, from cluster group A to cluster set B, we will do: merge, simplify, split.</p><p id="62323c78-6b6a-46ff-b643-8c9b0149e386" class="">So, let&#x27;s assume our cluster group A has 3 clusters, the LOD error will be 0.1, 0.3, 0.5. Then they are merged, and simplified, split into two new clusters on the right. Considering the simplification, the error may be higher than before.</p><p id="bfbee7bf-f929-4984-a369-fb48b1e57e25" class="">So, for the left part, the cluster group will take find the minimal error from the children, in our case, it is 0.1. Then, from the generated new simplified clusters, it finds the max error and <strong>forces all the generated new clusters to have the same LOD error as this max error</strong>. This is important!</p><p id="34bf540a-1181-4903-8331-fe0ef77670d1" class="">Now, for the left cluster group, the range will be [0.1, 0.7]. And, if any other group (for example, cluster group B) contains the two newly generated clusters, the MaxParentLODError will be larger than the cluster group A&#x27;s  MaxParentLODError. Please remember this, I will use this in the next part.</p><h1 id="4904ba68-6fad-4214-b2ed-5b219f336dbb" class="">Encoding</h1><p id="d7a539b9-c04c-4467-9bd3-fbc8e1dd2590" class="">The pre-processed Nanite data ( clusters and cluster groups) will be encoded and send to GPU memory for accessing by computing shaders.</p><p id="2436c1b8-34a0-4854-b8d7-258a99d6bd3c" class="">The encoding code is the function Nanite::Encode in NaniteEncode.cpp.</p><p id="2a12534f-97d9-4d67-bd3c-45d415c540a7" class="">Now we need to deal with two different kinds of data: the clusters, which contain triangles and more, are much more complex and huge, and the groups which are references and small.</p><h3 id="46d9be68-af8c-45ca-9374-e6fa3de0566e" class="">Cluster Encoding</h3><p id="3c0df889-d829-4bf0-941e-6881e5df2901" class="">For the clusters, Nanite encodes them into pages. The size of a page is fixed, so a group may be split into different pages. To achieve this, Nanite uses FClusterGroupPart to record.</p><p id="f5b09443-ff85-4db4-815c-aa04c0c72cba" class="">Page Assign<div class="indented"><p id="86a2b680-d3ea-4907-affe-cd05b6439ad8" class="">When a new page allocated, or we start recording a new group, a new cluster group part will be created. And the clusters will be set to the cluster group parts.</p><p id="94caac8f-c723-4ec9-9897-6cca7a840333" class="">(a green box is a cluster)</p><figure id="39b2e802-4a38-4257-9420-d725c5319a21" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%205.png"><img style="width:997px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%205.png"/></a></figure></div></p><p id="fb1feac3-61ef-495e-80c8-92e5dfeb3c08" class="">Hierarchies build<div class="indented"><p id="37f43724-1dcd-47d5-a1aa-b07fa9a85843" class="">First we need to know the max mip level by just find the highest mip level number of all groups.</p><p id="a1ca274c-49ac-4740-9924-d227a422f356" class="">But in the same mip level, we may still have many nodes:<div class="indented"><figure id="d6fcca3e-1e6a-4cfb-b4e0-6aa77aa250d6" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%206.png"><img style="width:189px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%206.png"/></a></figure></div></p><p id="21eace7f-4dc4-472c-9b3f-d3198eff9c3f" class="">So, instead of just use these level-based nodes, Nanite build a BVH tree to organize them into a tree of nodes that contains much smaller children for each node. In my test, the max children number is 8.</p><p id="11b1ad7d-e5a1-4135-aedf-97e15c87634b" class="">After this step, in my test, 138 nodes are added as BVH node to group those nodes.</p><figure id="5b688f58-a66d-466c-b0aa-84ddfff8e9ba" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%207.png"><img style="width:1252px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%207.png"/></a></figure><p id="985e2b1c-2f20-4974-a5d0-57089dbd2718" class="">If you enable the BVH_BUILD_WRITE_GRAPHVIZ macro, you can visualize the tree like this.</p><p id="564a76c8-1eb9-4195-83b1-1221278762bb" class="">Since the detail info is not so important, I just show a small screenshot.</p><p id="5586af90-2567-408a-a9fa-c66016b21059" class="">Be careful, this tree is <strong>NOT </strong>the same tree of cluster groups and clusters. This is a tree based on ClusterGroupPart. </p></div></p><h3 id="e46f4876-b8dd-47da-b869-a73bffb124d3" class="">Pack Hierarchies</h3><p id="b432f610-9a87-43c1-ba92-876fdbf78ad2" class="">Nanite gets all the hierarchy nodes( In my test, the number is 139 (138 + 1) ) and packed them into FPackedHierarchyNode for GPU to access.</p><pre id="4108d92e-c4e6-4a8b-a557-6ed7afeb3f2d" class="code"><code>struct FPackedHierarchyNode
{
	FSphere		LODBounds[MAX_BVH_NODE_FANOUT];
	
	struct
	{
		FVector		BoxBoundsCenter;
		uint32		MinLODError_MaxParentLODError;
	} Misc0[MAX_BVH_NODE_FANOUT];

	struct
	{
		FVector		BoxBoundsExtent;
		uint32		ChildStartReference;
	} Misc1[MAX_BVH_NODE_FANOUT];
	
	struct
	{
		uint32		ResourcePageIndex_NumPages_GroupPartSize;
	} Misc2[MAX_BVH_NODE_FANOUT];
};</code></pre><p id="a799c85a-4d4d-4603-92d2-aab624d05a25" class="">Just a little about &#x27;for GPU to access&#x27;: FPackedHierarchyNode data will be upload to the HierarchyBuffer in GPU memory. Then decode by this code</p><pre id="6ee49e82-e3a1-4d8a-ac0b-44cf1284d9ce" class="code"><code>FHierarchyNodeSlice GetHierarchyNodeSlice( uint NodeIndex, uint ChildIndex )
{
	const uint NodeSize = ( 4 + 4 + 4 + 1 ) * 4 * MAX_BVH_NODE_FANOUT;

	uint BaseAddress = NodeIndex * NodeSize;

	FHierarchyNodeSlice Node;
	Node.LODBounds			=	asfloat(	HierarchyBuffer.Load4( BaseAddress + 16 * ChildIndex) );
	
	uint4 Misc0				=	HierarchyBuffer.Load4( BaseAddress + (MAX_BVH_NODE_FANOUT * 16) + 16 * ChildIndex);
	uint4 Misc1				=	HierarchyBuffer.Load4( BaseAddress + (MAX_BVH_NODE_FANOUT * 32) + 16 * ChildIndex);
	uint  Misc2				=	HierarchyBuffer.Load ( BaseAddress + (MAX_BVH_NODE_FANOUT * 48) +  4 * ChildIndex);
	Node.BoxBoundsCenter	=	asfloat( Misc0.xyz );
	Node.BoxBoundsExtent	=	asfloat( Misc1.xyz );

	Node.MinLODError		=	f16tof32( Misc0.w );
	Node.MaxParentLODError	=	f16tof32( Misc0.w &gt;&gt; 16 );
	Node.ChildStartReference=	Misc1.w;
	Node.bLoaded			=	Misc1.w != 0xFFFFFFFFu;

	uint ResourcePageIndex_NumPages_GroupPartSize = Misc2;
	Node.NumChildren		=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_CLUSTERS_PER_GROUP_BITS, 0);
	Node.NumPages			=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_GROUP_PARTS_BITS, MAX_CLUSTERS_PER_GROUP_BITS);
	Node.StartPageIndex		=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_RESOURCE_PAGES_BITS, MAX_CLUSTERS_PER_GROUP_BITS + MAX_GROUP_PARTS_BITS);
	Node.bEnabled			=	ResourcePageIndex_NumPages_GroupPartSize != 0u;
	Node.bLeaf				=	ResourcePageIndex_NumPages_GroupPartSize != 0xFFFFFFFFu;

	return Node;
}</code></pre><p id="b485cc1c-b0ae-4b51-80d9-c7f8bf059107" class="">After decode, shader will get this data:</p><pre id="0b50a1a3-21af-49db-be38-53b8a24d2ffd" class="code"><code>struct FHierarchyNodeSlice
{
	float4	LODBounds;
	float3	BoxBoundsCenter;
	float3	BoxBoundsExtent;
	float	MinLODError;
	float	MaxParentLODError;
	uint	ChildStartReference;	// Can be node (index) or cluster (page:cluster)
	uint	NumChildren;
	uint	StartPageIndex;
	uint	NumPages;
	bool	bEnabled;
	bool	bLoaded;
	bool	bLeaf;
};</code></pre><p id="f50d6beb-0855-4ebf-92d7-c322604bd477" class="">I will talk about decoding and usage in another part. So I just let you know how this data structure will be used.</p><p id="1261a9c6-cbfe-4acc-9443-12b2c997d573" class="">
</p><h3 id="96b64a1d-d7f5-4a3c-aa65-3b6889ebbd28" class="">A Tree of Mips</h3><p id="856b1e68-8858-4178-937a-f4b2dc9b15e0" class="">So, let&#x27;s make a summary, Nanite will build a tree like this:</p><figure id="4d856c89-f0e0-4f7b-bfcd-d9937cf72633" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%208.png"><img style="width:382px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%208.png"/></a></figure><p id="5706098b-96f6-4a2b-8d3d-af4cf1b2a255" class="">One question is, <strong>WHY</strong>?</p><p id="869e9beb-07b2-4dc8-ac1c-737e2f6a0f5e" class="">It looks like  we have many duplicated version of the same mesh inside one tree. Because different mips will cover each other although they are in different LOD levels.</p><p id="034a0162-bb95-415a-8d4f-ae69fa2a8170" class="">I will explain more in the next part, but since this question takes me long time to figure out, let me give you a short answer:</p><p id="c4c6ca66-6628-4af0-a6a2-91f5f9adb0c1" class="">Yes, different mips will be store inside the same tree, but during the culling, for a specific area, only one best part will be selected by considering the LOD error.</p><h1 id="c39f7e75-5fc0-4298-9207-044978a33ecb" class="">Decoding and Usage</h1><div id="1d1b14ac-0b90-4f6c-97cc-1b322631bd8f" class="column-list"><div id="481d414e-5e92-43c2-9f49-a037637dc0cb" style="width:50%" class="column"><figure id="568be2df-effe-4218-b002-42852641bd28" class="image"><a href="https://kroki.io/plantuml/svg/eNpVjUsOg0AMQ_dzipwDllOJLaLqASLGAqT5NWRU9fZNgQ07-9myd2VRJ6hgdZ0fX9RqLBwosDJpocFQQiry7V33wFwCjsycbzFueTE1IQfIqQdkCCvomBG8G3Y1_rTOjf3X7bC_3umzbhHOWj-1zjLE"><img style="width:400px" src="https://kroki.io/plantuml/svg/eNpVjUsOg0AMQ_dzipwDllOJLaLqASLGAqT5NWRU9fZNgQ07-9myd2VRJ6hgdZ0fX9RqLBwosDJpocFQQiry7V33wFwCjsycbzFueTE1IQfIqQdkCCvomBG8G3Y1_rTOjf3X7bC_3umzbhHOWj-1zjLE"/></a></figure></div><div id="f4ee8353-7508-42e4-8057-986d3f9e1e9a" style="width:50%" class="column"><p id="8dc7b02c-eed7-4f86-b1e3-f9b8f057584c" class="">As a virtual geometry system like virtual texture, the system should have a feedback loop like this. CPU uploads the requested data to GPU, and the GPU will tell the CPU about the request data in the next frame.</p></div></div><p id="6ba3033a-c4bd-4553-877f-02b0fdfe73e6" class="">So we start at the culling part to see how Nanite works with this system.</p><h2 id="2d0205ff-a889-4836-9ce5-2ffc1e82c749" class="">Culling</h2><p id="3b431619-601e-41b0-aed4-7becc6852517" class="">Nanite has two culling steps: instance culling and persistent culling. In this article, we skip the instance culling part and focus on the persistent culling to see how Nanite does the persistent cluster culling. (And this is a really interesting part. If you open ClusterCulling.usf you will see a long comment before the PersistentClusterCull function).</p><p id="86a6fd0c-db2e-4e15-bf02-313b1d1241f8" class="">The culling part need to achieve two targets: remove invisible nodes, and find best cluster with current error threshold.</p><p id="830294df-7547-4fce-bdad-5b5e1f2055ff" class="">For the first target, it is done by Frustum Culling and HZB Culling based on the bounds of each node. I will skip this part.</p><p id="95a2909f-fd09-4c03-9fc7-4329be4056d6" class="">And, for the second target, do you remember two things we mentioned before:</p><ol id="a3b831cf-8c5d-4d70-ab40-e591ef4b770e" class="numbered-list" start="1"><li>Each cluster group (which is the culling unit) has a MaxLODError, and cluster group B contains simplified clusters of cluster group A will have higher MaxLODError.</li></ol><ol id="aabed275-ad56-4373-9296-dc1e65069b59" class="numbered-list" start="2"><li>The hierarchies nodes contains all the mip of cluster groups.</li></ol><p id="c5d52a2b-a9bb-4312-8fa3-6bdbd4c16386" class="">Lets&#x27; find a best slice of cluster groups like Epic explained in the official Inside Unreal talk:</p><figure id="cc0c54ba-e312-4f18-a365-e2ae4a673269" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%209.png"><img style="width:722px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%209.png"/></a></figure><p id="f0cdc3a3-82c2-42b7-b790-6f1371d6a42b" class="">(This is a conceptual image, not the acutal node tree)</p><p id="b6d0a3e6-5836-4794-ae5e-4e1ac75d0406" class="">There are two rules:</p><ol id="18b2cdf7-367d-4336-ac5a-1a3e80979f4b" class="numbered-list" start="1"><li>For a node, if the max LOD error is larger than the target value, we will visit its children. Otherwise, we ignore this node&#x27;s children since it is too detailed. The code is the ShouldVisitChild function in ClusterCulling.usf.</li></ol><ol id="f0c2e6ac-42a4-4778-ae89-67e641885a9c" class="numbered-list" start="2"><li>For a cluster, if the LOD error is lower than the target value, we will choose this cluster. The code is in the SmallEnoughToDraw function in ClusterCulling.usf.</li></ol><p id="68b036e5-43d1-4cc2-96e5-7dfd100fa413" class="">So, I will answer the question that why these two parts will not be visible at the same time:</p><figure id="da2ae7a7-1bde-43ad-8a0a-d942434fa6fc" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%204.png"><img style="width:566px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%204.png"/></a></figure><p id="c97cddd3-11e9-48e6-b6cf-750c03fa67e8" class="">(Please notify, the following explaination is just for easier explain the selection process, the detail calculation is much more complicated)</p><div id="0b6ba5db-7996-4dab-bfc4-ee4954350512" class="column-list"><div id="339e42da-818c-4130-a11c-8e40829fcf08" style="width:50%" class="column"><figure id="5a1ecde9-3531-40db-80d3-59f5f1498676" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2010.png"><img style="width:772px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2010.png"/></a></figure></div><div id="4a54101d-b90b-4104-b43a-6e96367a0ed6" style="width:50%" class="column"><p id="a4b0bdf8-be3b-429e-9cf6-21a91e39ead2" class="">Now let&#x27;s look at this fake tree. The MaxLODError of each node is showed in the rect. </p><p id="bd9a7a43-5083-4a2d-84f2-6b651e1a71a8" class="">Let&#x27;s assume we are looking for a slice of error 0.5. We start with the top mip nodes. The mip 2 and 3 are too detailed so their max LOD errors are smaller than 0.5. They will not be visited .(sorry ...)</p><p id="e2f9dc32-b4f2-4948-b691-f9cab688145f" class="">Now for the mip 3 and 4, they are visited based on the 1st rule.</p><p id="92dd5c4a-9b81-4a6d-959e-2a4587d16342" class="">In the end, both the red cluster group and the right blue cluster group will be visited, then we apply the 2nd rule. Since only the red cluster group cluster has errors lower than 0.5, we will let left clusters visible, and make the two parts in the blue group invisible.</p><p id="2081955e-92ae-48e0-aba3-204e62d8c67f" class="">
</p></div></div><div id="33617aaa-5773-4341-a577-788199b48763" class="column-list"><div id="64136ce7-0932-4a2f-8489-948e5528e832" style="width:50%" class="column"><figure id="a0f750b0-52e4-487c-bf9f-47ea89456c4b" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2011.png"><img style="width:279px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2011.png"/></a></figure></div><div id="46f07be3-0739-4e74-9d81-a8d5ff4677cb" style="width:50%" class="column"><p id="429524c3-2bd9-4f17-b6cc-65a4954d74d2" class="">We can image this selection as &quot;the 3 clusters in the red cluster group are replaced the two clusters in the blue group&quot;. </p></div></div><p id="d38b5f17-f3b0-4e83-b645-190bb525d1dc" class="">Let&#x27;s do this again, but now we choose the error value as 0.8.</p><div id="7899e777-fbd5-4c3b-96d5-d33f4bd25197" class="column-list"><div id="5993d17e-ce3a-418b-a379-d3087c178a0a" style="width:50%" class="column"><figure id="59fd8622-0945-4e38-9825-38382af270cf" class="image"><a href="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2012.png"><img style="width:726px" src="Brief%20Analysis%20of%20Nanite%20748b85e3917d4107ac04786c435684dd/Untitled%2012.png"/></a></figure></div><div id="c7081886-ccc0-4fe4-bbed-4eff225ca791" style="width:50%" class="column"><p id="dc427b5f-4271-45e1-bec5-1f5cfbb6619d" class="">Now the node with 0.71 Max error is <strong>not </strong>larger than the target error 0.8. We will not visit this node. But the blue group will be visited. And since 0.7 is smaller than 0.8, the two clusters inside the blue cluster group will be visible.</p></div></div><p id="5b9984c5-6b8f-4fbc-bd62-dc4a23d28cd6" class="">Now please let me make a summary: with this design, Nanite will choose a cluster target, both considering about the detail ( for lower Max LOD error of each node) and the performance (for choosing a cluster just a little bit lower than the target error). The LOD error of two simplified clusters will be force to have the same LOD error (<a href="https://www.notion.so/Brief-Analysis-of-Nanite-94be60f292434ba3ae62fa4bcf7d9379#bfbee7bff9294984a369fb48b1e57e25">https://www.notion.so/Brief-Analysis-of-Nanite-94be60f292434ba3ae62fa4bcf7d9379#bfbee7bff9294984a369fb48b1e57e25</a>) makes the transition from the simplified clusters to the detailed version happens in the same time, so there will be no holes. Because the two clusters inside the blue cluster group will never have a chance to be visible and invisible individually, they have the same LOD error, and so will be choosed to show or hide in the same time. Genius! 天才！</p><h1 id="28877a50-5b49-4436-a598-ef35a0fd9eda" class="">In the End</h1><p id="77c80603-72ee-4eaf-9c4f-36a3dc198a64" class="">I planned to discuss more details about Nanite based on the source code, but I want to split these articles into many parts (like Nanite). I need more time to read the Nanite&#x27;s shader codes.</p><p id="4628fe80-09ab-4d34-8e88-d061b15dcf8e" class="">The design of Nanite is a great work, the ideas behind that are always shock me. Really thanks for Epic to develop this great system, and open the source code for everyone to learn from Nanite. </p><p id="77402726-5bcb-4ca0-94bd-946bf2a3a6fd" class="">And, really thanks for every people reading, discussing and sharing the ideas based on analysis of Nanite. I also learn many things from you.</p><p id="b74e4828-b670-41b8-a886-9d2d2a00bb70" class="">See you again!</p></div></article></body></html>